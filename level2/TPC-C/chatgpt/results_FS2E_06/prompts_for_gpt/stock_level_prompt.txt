
You are a PostgreSQL expert specializing in transactional workloads.
Using the database schema and the transaction description provided, generate a valid PostgreSQL stored function that implements the transaction.
The examples below show SQL patterns, but DO NOT copy them literally.
Analyze the current question independently and create the most appropriate transaction.


Requirements:
- Create a PostgreSQL function using CREATE OR REPLACE FUNCTION syntax
- Include all necessary input and output parameters
- Implement the complete transaction logic as described
- Use RETURNS TABLE(...) ONLY when returning multiple rows of data
- NEVER mix OUT parameters with non-table return types
- Always qualify column names with table aliases in JOINs (e.g., w.w_name, not just w_name)
- Avoid ambiguous column references
- Use PL/pgSQL language
- Return ONLY the SQL code without any markdown formatting or explanations
- The function should be ready to execute in PostgreSQL
- RESPECT THE INPUTS AND OUTPUTS PARAMETERS, RESPECT FOREIGN KEY CONSTRAINTS, CAREFUL WITH AMBIGUOUS REFERENCES FOR COLUMNS AND TABLES

Format: Return the complete CREATE OR REPLACE FUNCTION statement.


DATABASE SCHEMA:
create table bmsql_config (
  cfg_name    varchar(30) primary key,
  cfg_value   varchar(50)
);

create table bmsql_warehouse (
  w_id        integer   not null,
  w_ytd       decimal(12,2),
  w_tax       decimal(4,4),
  w_name      varchar(10),
  w_street_1  varchar(20),
  w_street_2  varchar(20),
  w_city      varchar(20),
  w_state     char(2),
  w_zip       char(9)
);

create table bmsql_district (
  d_w_id       integer       not null,
  d_id         integer       not null,
  d_ytd        decimal(12,2),
  d_tax        decimal(4,4),
  d_next_o_id  integer,
  d_name       varchar(10),
  d_street_1   varchar(20),
  d_street_2   varchar(20),
  d_city       varchar(20),
  d_state      char(2),
  d_zip        char(9)
);

create table bmsql_customer (
  c_w_id         integer        not null,
  c_d_id         integer        not null,
  c_id           integer        not null,
  c_discount     decimal(4,4),
  c_credit       char(2),
  c_last         varchar(16),
  c_first        varchar(16),
  c_credit_lim   decimal(12,2),
  c_balance      decimal(12,2),
  c_ytd_payment  decimal(12,2),
  c_payment_cnt  integer,
  c_delivery_cnt integer,
  c_street_1     varchar(20),
  c_street_2     varchar(20),
  c_city         varchar(20),
  c_state        char(2),
  c_zip          char(9),
  c_phone        char(16),
  c_since        timestamp,
  c_middle       char(2),
  c_data         varchar(500)
);

create table bmsql_history (
  h_c_id   integer,
  h_c_d_id integer,
  h_c_w_id integer,
  h_d_id   integer,
  h_w_id   integer,
  h_date   timestamp,
  h_amount decimal(6,2),
  h_data   varchar(24)
);

create table bmsql_new_order (
  no_w_id  integer   not null,
  no_d_id  integer   not null,
  no_o_id  integer   not null
);

create table bmsql_oorder (
  o_w_id       integer      not null,
  o_d_id       integer      not null,
  o_id         integer      not null,
  o_c_id       integer,
  o_carrier_id integer,
  o_ol_cnt     integer,
  o_all_local  integer,
  o_entry_d    timestamp
);

create table bmsql_order_line (
  ol_w_id         integer   not null,
  ol_d_id         integer   not null,
  ol_o_id         integer   not null,
  ol_number       integer   not null,
  ol_i_id         integer   not null,
  ol_delivery_d   timestamp,
  ol_amount       decimal(6,2),
  ol_supply_w_id  integer,
  ol_quantity     integer,
  ol_dist_info    char(24)
);

create table bmsql_item (
  i_id     integer      not null,
  i_name   varchar(24),
  i_price  decimal(5,2),
  i_data   varchar(50),
  i_im_id  integer
);

create table bmsql_stock (
  s_w_id       integer       not null,
  s_i_id       integer       not null,
  s_quantity   integer,
  s_ytd        integer,
  s_order_cnt  integer,
  s_remote_cnt integer,
  s_data       varchar(50),
  s_dist_01    char(24),
  s_dist_02    char(24),
  s_dist_03    char(24),
  s_dist_04    char(24),
  s_dist_05    char(24),
  s_dist_06    char(24),
  s_dist_07    char(24),
  s_dist_08    char(24),
  s_dist_09    char(24),
  s_dist_10    char(24)
);


Here are some examples of questions and their corresponding SQL queries:

--- Example 1 ---
QUESTION:
= The Order-Status Transaction
The Order-Status business transaction queries the status of a customer's last order. It represents a mid -weight read - only database transaction with a low frequency of execution and response time requirement to satisfy on -line users. In addition, this table includes non -primary key access to the CUSTOMER table.

== Input Data Generation
    -> For any given terminal, the home warehouse number (W_ID) is constant over the whole measurement interval.
    -> The district number (D_ID) is randomly selected within [1 ..10] from the home warehouse. The customer is randomly selected 60% of the time by last name (C_W_ID, C_D_ID, C_LAST) and 40% of the time by number (C_W_ID, C_D_ID, C_ID) from the selected district (C_D_ID = D_ID) and the home warehouse number (C_W_ID = W_ID). This can be implemented by generating a random number y within [1 .. 100];
        • If y <= 60 a customer last name (C_LAST) is generated from a non-uniform random value using the NURand(255,0,999) function. The customer is using his/ her last name and is one of the, possibly several, customers with that last name.
        Comment: This case illustrates the situation when a customer does not use his/ her unique customer number.
        • If y > 60 a non-uniform random customer number (C_ID) is selected using the NURand (1023,1,3000) function. The customer is using his/ her customer number.
    -> Inputs: (W_ID integer, D_ID integer, C_ID integer, C_LAST varchar(16))
    -> Outputs: (C_ID integer, C_FIRST varchar(16), C_MIDDLE char(2), C_BALANCE decimal(12,2), O_ID integer, O_ENTRY_D varchar(24), O_CARRIER_ID integer, OL_SUPPLY_W_ID integer[], OL_I_ID integer[], OL_QUANTITY integer[], OL_AMOUNT decimal(12,2)[], OL_DELIVERY_D timestamp[])
    -> NOTE: If an order contains fewer than 15 items, the output arrays must be padded to 15 elements with default values (0 for integer arrays, 0.0 for decimal arrays, and NULL for timestamp arrays) to accommodate the maximum displayable order lines 
    
== Transaction Profile
    -> Querying for the status of an order is done in a single database transaction with the following steps:
        1. Find the customer and his/ her last order, comprised of:
            Case 1, the customer is selected based on customer number:
                2 row selections with data retrieval.,
            Case 2, the customer is selected based on customer last name:
            4 row selections (on average) with data retrieval.
        2. Check status (delivery date) of each item on the order (average items-per-order = 10), comprised of: (1 * items-per-order) row selections with data retrieval.
    Note: The above summary is provided for information only. The actual requirement is defined by the detailed transaction profile below.

    -> For a given customer number (C_W_ID , C_D_ID , C_ ID):
        • The input data are communicated to the SUT.
        • A database transaction is started.
        • Case 1, the customer is selected based on customer number: the row in the CUSTOMER table with matching C_W_ID, C_D_ID, and C_ID is selected and C_BALAN CE, C_FIRST, C_MIDDLE, and C_LAST are retrieved. 
        Case 2, the customer is selected based on customer last name: all rows in the CUSTOMER table with matching C_W_ID, C_D_ID and C_LAST are selected sorted by C_FIRST in ascending order. Let n be the number of rows selected. C_BALANCE, C_FIRST, C_MIDDLE, and C_LAST are retrieved from the row at position n/ 2 rounded up in the sorted set of selected rows from the CUSTOMER table.
        • The row in the ORDER table with matching O_W_ID (equals C_W_ID), O_D_ID (equals C_D_ID), O_C_ID (equals C_ID), and with the largest existing O_ID, is selected. This is the most recent order placed by that customer. O_ID, O_ENTRY_D, and O_CARRIER_ID are retrieved.
        • All rows in the ORDER-LINE table with matching OL_W_ID (equals O_W_ID), OL_D_ID (equals O_D_ID), and OL_O_ID (equals O_ID) are selected and the corresponding sets of OL_I_ID, OL_SUPPLY_W_ID, OL_QUANTITY, OL_AMOUNT, and OL_DELIVERY_D are retrieved.
        • The database transaction is committed .
            Comment: a commit is not required as long as all ACID properties are satisfied.
        • The output data are communicated to the terminal.

== Terminal I/O
    -> For each transaction the originating terminal must display the follow ing input/ output screen with all input and output field s cleared (with either spaces or zeros) except for the Warehouse field which has not changed and must display the fixed W_ID value associated with that terminal.
    -> The emulated user must enter, in the appropriate field of the input/ output screen, the required input
    data which is organized as the distinct fields: D_ID and either C_ID or C_LAST.
    -> The emulated terminal must display, in the approp riate fields of the input/ output screen, all input data and the output data resulting from the execution of the transaction. The display field s are divided in two groups as follows:
        • One non-repeating group of fields: W_ID, D_ID, C_ID, C_FIRST, C_MIDDLE, C_LAST, C_BALANCE, O_ID, O_ENTRY_D, and O_CARRIER_ID;
        • One repeating group of fields: OL_SUPPLY_W_ID, OL_I_ID, OL_QUANTITY, OL_AMOUNT, and OL_DELIVERY_D. The group is repeated O_OL_CNT times (once per item in the order).
    Comment 1: The order of items shown on the Order-Status screen does not need to match the order in which the items were entered in its corresponding New -Order screen.
    Comment 2: If OL_DELIVERY_D is null (i.e., the order has not been delivered), the terminal must display an implementation specific null date representation (e.g., blanks, 99-99-9999, etc.). The chosen null date representation must not change during the test.
    Comment 3: If an order contains fewer than 15 items, the output arrays must be padded to 15 elements with default values (0 for integer arrays, 0.0 for decimal arrays, and NULL for timestamp arrays) to accommodate the maximum displayable order lines (rows 8-22 on the terminal screen).

    -> The following table summarizes the terminal I/ O requirements for the Order-Status transaction:
        Enter Display Coordinates
        Row/ Column
        Non-repeating Group W_ID 2/ 12
        D_ID D_ID 2/ 29
        C_ID 1 C_ID 3/ 11
        C_FIRST 3/ 24
        C_MIDDLE 3/ 41
        C_LAST 2 C_LAST 3/ 44
        C_BALANCE 4/ 16
        O_ID 6/ 15
        O_ENTRY_D 6/ 38
        O_CARRIER_ID 6/ 76
        Repeating Group OL_SUPPLY_W_ID 8-22/ 3
        OL_I_ID 8-22/ 14
        OL_QUANTITY 8-22/ 25
        OL_AMOUNT 8-22/ 33
        OL_DELIVERY_D 8-22/ 47
        1 Enter only for query by customer number. 2
        Enter only for query by customer last name.

SQL QUERY:
CREATE OR REPLACE FUNCTION bmsql_proc_order_status(
    IN in_w_id integer,
    IN in_d_id integer,
    INOUT in_c_id integer,
    IN in_c_last varchar(16),
    OUT out_c_first varchar(16),
    OUT out_c_middle char(2),
    OUT out_c_balance decimal(12,2),
    OUT out_o_id integer,
    OUT out_o_entry_d varchar(24),
    OUT out_o_carrier_id integer,
    OUT out_ol_supply_w_id integer[],
    OUT out_ol_i_id integer[],
    OUT out_ol_quantity integer[],
    OUT out_ol_amount decimal(12,2)[],
    OUT out_ol_delivery_d timestamp[]
) AS
$$
DECLARE
	v_order_line	record;
	v_ol_idx		integer := 1;
BEGIN
    --If C_LAST is given instead of C_ID (60%), determine the C_ID.
    IF in_c_last IS NOT NULL THEN
		in_c_id = bmsql_cid_from_clast(in_w_id, in_d_id, in_c_last);
    END IF;

    --Select the CUSTOMER
    SELECT INTO out_c_first, out_c_middle, in_c_last, out_c_balance
			c_first, c_middle, c_last, c_balance
		FROM bmsql_customer
		WHERE c_w_id=in_w_id AND c_d_id=in_d_id AND c_id = in_c_id;

    --Select the last ORDER for this customer.
    SELECT INTO out_o_id, out_o_entry_d, out_o_carrier_id
			o_id, o_entry_d, coalesce(o_carrier_id, -1)
		FROM bmsql_oorder
		WHERE o_w_id = in_w_id AND o_d_id = in_d_id AND o_c_id = in_c_id
		AND o_id = (
			SELECT max(o_id)
				FROM bmsql_oorder
				WHERE o_w_id = in_w_id AND o_d_id = in_d_id AND o_c_id = in_c_id
			);

	FOR v_order_line IN SELECT ol_i_id, ol_supply_w_id, ol_quantity,
				ol_amount, ol_delivery_d
			FROM bmsql_order_line
			WHERE ol_w_id = in_w_id AND ol_d_id = in_d_id AND ol_o_id = out_o_id
			ORDER BY ol_w_id, ol_d_id, ol_o_id, ol_number
			LOOP
	    out_ol_i_id[v_ol_idx] = v_order_line.ol_i_id;
	    out_ol_supply_w_id[v_ol_idx] = v_order_line.ol_supply_w_id;
	    out_ol_quantity[v_ol_idx] = v_order_line.ol_quantity;
	    out_ol_amount[v_ol_idx] = v_order_line.ol_amount;
	    out_ol_delivery_d[v_ol_idx] = v_order_line.ol_delivery_d;
		v_ol_idx = v_ol_idx + 1;
	END LOOP;

    WHILE v_ol_idx < 16 LOOP
		out_ol_i_id[v_ol_idx] = 0;
		out_ol_supply_w_id[v_ol_idx] = 0;
		out_ol_quantity[v_ol_idx] = 0;
		out_ol_amount[v_ol_idx] = 0.0;
		out_ol_delivery_d[v_ol_idx] = NULL;
		v_ol_idx = v_ol_idx +1;
    END LOOP;
END;
$$
Language plpgsql;

--- Example 2 ---
QUESTION:
= The Delivery Transaction
The Delivery business transaction consists of processing a batch of 10 new (not yet delivered) orders. Each order is processed (delivered) in full within the scope of a read -write database transaction. The number of orders delivered as a group (or batched) within the same database transaction is implementation specific. The business transaction, comprised of one or more (up to 10) database transactions, has a low frequency of execution and must complete within a relaxed response time requirement.
The Delivery transaction is intended to be executed in deferred mode through a queuing mechanism, rather than interactively, with terminal response indicating transaction completion. The result of the deferred execution is recorded into a result file.

== Input Data Generation
    -> For any given terminal, the home warehouse number (W_ID) is constant over the whole measurement interval.
    -> The carrier number (O_CARRIER_ID) is random ly selected within [1 .. 10].
    -> The delivery date (OL_DELIVERY_D).
    -> Inputs: (w_id_in, o_carrier_id, ol_delivery_d)
    -> Output: (delivered_o_id integer[])

== Deferred Execution
    -> Unlike the other transactions in this benchmark, the Delivery transaction must be executed in deferred mode. This mode of execution is primarily characterized by queuing the transaction for defe rred execution, returning control to the originating terminal independently from the completion of the transaction, and recording execution information into a result file.
    -> Deferred execution of the Delivery transaction must adhere to the following rules:
        1. The business transaction is queued for deferred execution as a result of entering the last input character.
        2. The deferred execution of the business transaction must follow the profile with the input data as entered through the input/ output screen and communicated to the deferred execution queue.
        3. At least 90% of the business transaction s must complete within 80 seconds of their being queued for execution.
        4. Upon completion of the business transaction , the following information must have been recorded into a result file:
            • The time at which the business transaction was queued.
            • The warehouse number (W_ID) and the carried number (O_CARRIER_ID) associated with the business transaction.
            • The district number (D_ID) and the order number (O_ID) of each order delivered by the business transaction.
            • The time at which the business transaction completed.
    -> The result file associated with the deferred execution of the Delivery business transaction is only for the purpose of recording information about that transaction and is not relevant to the business function being performed. The result file must adhere to the following rules:
        1. All events must be completed before the related information is recorded (e.g., the recording of a district and order number must be done after the database transaction , within which this order was delivered, has been committed );
        2. No ACID property is required (e.g., the recording of a district and order number is not required to be atomic with the actual delivery of that order) as the result file is used for benchmarking purposes only.
        3. During the measurement interval the result file must be located either on a durable medium or in the internal memory of the SUT. In this last case, the result file m ust be transferred onto a durable medium after the last measurement interval of the test run.

== Terminal I/O
    -> For each transaction the originating terminal must display the following input/ output screen with all input and output field s cleared (with either spaces or zeros) except for the Warehouse field which has not changed and must display the fixed W_ID value associated with that terminal.
    -> The emulated user must enter, in the appropriate input field of the input/ output screen, the required input data which is organized as one distinct field: O_CARRIER_ID.
    -> The emulated terminal must display, in the appropriate output field of the input/ output screen, all input data and the output data which results from the queuing of the transaction. The following fields are displayed: W_ID, O_CARRIER_ID, and the status message "Delivery has been queued".

    -> The following table summarizes the terminal I/ O requirements for the Delivery transaction :
        Enter Display Coordinates
        Row/ Column
        Non-repeating Group W_ID 2/ 12
        O_CARRIER_ID O_CARRIER_ID 4/ 17
        "Delivery has been queued" 6/ 19

== Transaction Profile
    -> The deferred execution of the Delivery transaction delivers one outstanding order (average items-perorder = 10) for each one of the 10 districts of the selected warehouse using one or more (up to 10) database transactions. Delivering each order is done in the following steps:
        1. Process the order, comprised of:
            1 row selection with data retrieval,
            (1 + items-per-order) row selections with data retrieval and update.
        2. Update the customer's balance, comprised of:
            1 row selections with data update.
        3. Remove the order from the new-order list, comprised of:
            1 row deletion.
    Comment: This business transaction can be done within a single database transaction or broken down into up to 10 database transactions to allow the test sponsor the flexibility to implement the business transaction with the most efficient number of database transactions. Note: The above summary is provided for information only. The actual requirement is defined by the detailed transaction profile below.

    -> For a given warehouse number (W_ID), for each of the 10 districts (D_W_ID , D_ID) within that warehouse, and for a given carrier number (O_CARRIER_ID):
        • The input data are retrieved from the deferred execution queue.
        • A database transaction is started unless a database transaction is already active from being started as part of the delivery of a previous order (i.e., more than one order is delivered within the same database transaction).
        • The row in the NEW-ORDER table with matching NO_W_ID (equals W_ID) and NO_D_ID (equals D_ID) and with the lowest NO_O_ID value is selected. This is the oldest undelivered order of that district. NO_O_ID, the order number, is retrieved. If no matching row is found, then the delivery of an order for this district is skipped. The condition in which no outstandin g order is present at a given district must be handled by skipping the delivery of an order for that district only and resuming the delivery of an order from all remaining districts of the selected warehouse. If this condition occurs in more than 1%, or in more than one, whichever is greater, of the business transaction s, it must be reported. The result file must be organized in such a way that the percentage of skipped deliveries and skipped districts can be determined.
        • The selected row in the NEW-ORDER table is deleted.
        • The row in the ORDER table with matching O_W_ID (equals W_ ID), O_D_ID (equals D_ID), and O_ID (equals NO_O_ID) is selected, O_C_ID, the customer number, is retrieved, and O_CARRIER_ID is updated.
        • All rows in the ORDER-LINE table with matching OL_W_ID (equals O_W_ID), OL_D_ID (equals O_D_ID), and OL_O_ID (equals O_ID) are selected. All OL_DELIVERY_D, the delivery dates, are updated to the current system time as returned by the operating system and the sum of all OL_AMOUNT is retrieved.
        • The row in the CUSTOMER table with matching C_W_ID (equals W_ID), C_D_ID (equals D_ID), and C_ID (equals O_C_ID) is selected and C_BALANCE is increased by the sum of all order-line amounts (OL_AMOUNT) previously retrieved. C_DELIVERY_CNT is incremented by 1.
        • The database transaction is committed unless more ord ers will be delivered within this database transaction.
        • Information about the delivered order is recorded into the result file.

SQL QUERY:
CREATE OR REPLACE FUNCTION bmsql_proc_delivery_bg(
	IN in_w_id integer,
	IN in_o_carrier_id integer,
	IN in_ol_delivery_d timestamp,
	OUT out_delivered_o_id integer[]
) AS
$$
DECLARE
	var_d_id integer;
	var_o_id integer;
	var_c_id integer;
	var_sum_ol_amount decimal(12, 2);
BEGIN
	FOR var_d_id IN 1..10 LOOP
		var_o_id = -1;
		/*
		 * Try to find the oldest undelivered order for this
		 * DISTRICT. There may not be one, which is a case
		 * that needs to be reported.
		*/
		WHILE var_o_id < 0 LOOP
			SELECT INTO var_o_id
					no_o_id
				FROM bmsql_new_order
			WHERE no_w_id = in_w_id AND no_d_id = var_d_id
			ORDER BY no_o_id ASC;
			IF NOT FOUND THEN
			    var_o_id = -1;
				EXIT;
			END IF;

			DELETE FROM bmsql_new_order
				WHERE no_w_id = in_w_id AND no_d_id = var_d_id
				  AND no_o_id = var_o_id;
			IF NOT FOUND THEN
			    var_o_id = -1;
			END IF;
		END LOOP;

		IF var_o_id < 0 THEN
			-- No undelivered NEW_ORDER found for this District.
			var_d_id = var_d_id + 1;
			CONTINUE;
		END IF;

		/*
		 * We found out oldert undelivered order for this DISTRICT
		 * and the NEW_ORDER line has been deleted. Process the
		 * rest of the DELIVERY_BG.
		*/

		-- Update the ORDER setting the o_carrier_id.
		UPDATE bmsql_oorder
			SET o_carrier_id = in_o_carrier_id
			WHERE o_w_id = in_w_id AND o_d_id = var_d_id AND o_id = var_o_id;

		-- Get the o_c_id from the ORDER.
		SELECT INTO var_c_id
				o_c_id
			FROM bmsql_oorder
			WHERE o_w_id = in_w_id AND o_d_id = var_d_id AND o_id = var_o_id;

		-- Update ORDER_LINE setting the ol_delivery_d.
		UPDATE bmsql_order_line
			SET ol_delivery_d = in_ol_delivery_d
			WHERE ol_w_id = in_w_id AND ol_d_id = var_d_id
			  AND ol_o_id = var_o_id;

		-- SELECT the sum(ol_amount) from ORDER_LINE.
		SELECT INTO var_sum_ol_amount
				sum(ol_amount) AS sum_ol_amount
			FROM bmsql_order_line
			WHERE ol_w_id = in_w_id AND ol_d_id = var_d_id
			  AND ol_o_id = var_o_id;

		-- Update the CUSTOMER.
		UPDATE bmsql_customer
			SET c_balance = c_balance + var_sum_ol_amount,
				c_delivery_cnt = c_delivery_cnt + 1
			WHERE c_w_id = in_w_id AND c_d_id = var_d_id and c_id = var_c_id;

		out_delivered_o_id[var_d_id] = var_o_id;

		var_d_id = var_d_id +1 ;
	END LOOP;
END;
$$
LANGUAGE plpgsql;

--- Your Task ---
QUESTION:
= The Stock-Level Transaction
The Stock-Level business transaction determines the number of recently sold items that have a stock level below a specified threshold. It represents a heavy read -only database transaction with a low frequency of execution, a relaxed response time requirement, and relaxed consistency requirements.

== Input Data Generation
-> Each terminal must use a unique value of (W_ID, D_ID) that is constant over the whole measurement, i.e., D_IDs cannot be re-used within a warehouse.
-> The threshold of minimum quantity in stock (threshold ) is selected at random within [10 .. 20].
-> Inputs: (W_ID integer, D_ID integer, threshold integer)
-> Output: (low_stock integer)

== Transaction Profile
    -> Examining the level of stock for items on the last 20 orders is done in one or more database transactions with the following steps:
        1. Examine the next available order number, comprised of:
            1 row selection with data retrieval.
        2. Examine all items on the last 20 orders (average items-per-order = 10) for the district, comprised of: (20 * items-per-order) row selections with data retrieval.
        3. Examine, for each distinct item selected, if the level of stock available at the home warehouse is be low the threshold, comprised of:
        At most (20 * items-per-order) row selections with data retrieval.
        Note: The above summary is provided for information only. The actual requirement is defined by the detailed transaction profile below.
    -> For a given warehouse number (W_ID), district num ber (D_W_ID , D_ID), and stock level threshold (threshold):
        • The input data are communicated to the SUT.
        • A database transaction is started.
        • The row in the DISTRICT table with matching D_W_ID and D_ID is selected and D_NEXT_O_ID is retrieved. 
        • All rows in the ORDER-LINE table with matching OL_W_ID (equals W_ID), OL_D_ID (equals D_ID), and OL_O_ID (lower than D_NEXT_O_ID and greater than or equal to D_NEXT_O_ID minus 20) are selected. They are the items for 20 recent orders of the district.
        • All rows in the STOCK table with matching S_I_ID (equals OL_I_ID) and S_W_ID (equals W_ID) from the list of distinct item numbers and with S_QUANTITY lower than threshold are counted (giving low_stock). 
        Comment: Stocks must be counted only for distinct items. Thus, items that have been ordered more than once in the 20 selected orders must be aggregated into a single summary count for t hat item.
        • The current database transaction is committed.
        Comment: A commit is not needed as long as all the required ACID properties are satisfied.
        • The output data are communicated to the terminal.
    -> Full serializability and repeatable reads are not required for the Stock -Level business transaction. All data read must be committed and no older than the most recently committed d ata prior to the time this business transaction was initiated. All other ACID properties must be maintained.
    Comment: This clause allows the business transaction to be broken down into more than one database transaction.

==  Terminal I/O
    -> For each transaction the originating terminal must display the following input/ output screen with all input and output field s cleared (with either spaces or zeros) except for the Warehouse and District fields which have not changed and must display the fixed W_ID and D_ID values associated with that terminal.
    -> The emulated user must enter, in the appropriate field of the input/ output screen, the required input data which is organized as the distinct field: threshold. 
    -> The emulated terminal must display, in the appropriate field of the input/ output screen, all input data and the output data which results from the execution of the transaction. The following fields are displayed: W_ID, D_ID, threshold, and low_stock.

    -> The following table summarizes the terminal I/ O requirements for the Stock-Level transaction:
        Enter Display Coordinates
        Row/ Column
        Non-repeating Group W_ID 2/ 12
        D_ID 2/ 29
        threshold threshold 4/ 24
        low_stock 6/ 12

SQL QUERY:
